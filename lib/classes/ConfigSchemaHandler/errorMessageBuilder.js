'use strict';
const _ = require('lodash');

const ANY_OF_EVENT_SCHEMA_PATH =
  '#/properties/functions/patternProperties/%5E%5Ba-zA-Z0-9-_%5D%2B%24/properties/events/items/anyOf';

// matches '#/properties/functions/patternProperties/%5E%5Ba-zA-Z0-9-_%5D%2B%24/properties/events/items/anyOf/123/additionalProperties'
const ANY_OF_SUB_ERROR_REGEX = /^#\/properties\/functions\/patternProperties\/%5E%5Ba-zA-Z0-9-_%5D%2B%24\/properties\/events\/items\/anyOf\/[\d]+\/additionalProperties$/;

// matches '#/properties/functions/patternProperties/%5E%5Ba-zA-Z0-9-_%5D%2B%24/properties/events/items/anyOf/17/properties/yourPluginEvent/properties/anotherProp/type'
const DEEPER_ANY_OF_SUB_ERROR_REGEX = /^#\/properties\/functions\/patternProperties\/%5E%5Ba-zA-Z0-9-_%5D%2B%24\/properties\/events\/items\/anyOf\/[\d]+\/properties\/.+$/;

/*
 * Structure AJV errors to prevent secondary errors related to 'anyOf' condition
 * are not shown. Those errors are placed in `suberrors` array of the most
 * relevant error.
 */
const structureAjvErrors = ajvErrors => {
  // If theres is no 'anyOf' error at schemaPath that equals to
  // then do nothing and return ajvErrors
  if (!ajvErrors.filter(err => err.schemaPath === ANY_OF_EVENT_SCHEMA_PATH).length) {
    return ajvErrors;
  }

  let anyOfErrorIndex;
  ajvErrors.forEach((ajvError, key) => {
    if (ajvError.keyword === 'anyOf' && ajvError.schemaPath === ANY_OF_EVENT_SCHEMA_PATH) {
      anyOfErrorIndex = key;
    }
  });

  // Alternatively, if there is a deeper error, then it's better to make it parent
  // because it actually the reason why other errors are generated by AJV
  let deeperAnyOfErrorIndex;
  ajvErrors.forEach((ajvError, key) => {
    const isDeeperAnyOfSubErrorDeeper = DEEPER_ANY_OF_SUB_ERROR_REGEX.test(ajvError.schemaPath);
    if (isDeeperAnyOfSubErrorDeeper) {
      deeperAnyOfErrorIndex = key;
    }
  });

  const finalIndex =
    typeof deeperAnyOfErrorIndex === 'number' ? deeperAnyOfErrorIndex : anyOfErrorIndex;

  const result = [ajvErrors[finalIndex]];
  result[0].params.suberrors = [];
  ajvErrors.forEach((ajvError, index) => {
    const isAnyOfSubError = ANY_OF_SUB_ERROR_REGEX.test(ajvError.schemaPath);

    if (typeof deeperAnyOfErrorIndex === 'number') {
      if (isAnyOfSubError || index === anyOfErrorIndex) {
        result[0].params.suberrors.push(ajvError);
      } else if (index !== deeperAnyOfErrorIndex) {
        result.push(ajvError);
      }
    }

    if (typeof deeperAnyOfErrorIndex !== 'number') {
      if (isAnyOfSubError) {
        result[0].params.suberrors.push(ajvError);
      } else if (index !== anyOfErrorIndex) {
        result.push(ajvError);
      }
    }
  });

  return result;
};

/*
 * For error object structure, see https://github.com/ajv-validator/ajv/#error-objects
 */
const buildErrorMessages = (ajvErrors, userConfig = {}) => {
  let errors = ajvErrors;

  errors = structureAjvErrors(errors);

  errors = addUserFriendlyMessage(errors, userConfig);

  errors = errors.sort((a, b) => b.dataPath.length - a.dataPath.length);
  if (!errors.length) throw new Error('Validation errors array cannot be emptry');

  return errors.map(error => {
    if (error.friendlyMessage) {
      return error.friendlyMessage;
    }
    return buildDefaultErrorMessage(error);
  });
};

const buildDefaultErrorMessage = ajvError => {
  switch (ajvError.keyword) {
    case 'additionalProperties': {
      let additionalProperty;
      if (ajvError.params && ajvError.params.additionalProperty) {
        additionalProperty = ajvError.params.additionalProperty;
      }
      return `${ajvError.dataPath} ${ajvError.message} (received '${additionalProperty}')`;
    }
    default:
      return `${ajvError.dataPath} ${ajvError.message}`;
  }
};

const addUserFriendlyMessage = (errors, userConfig) => {
  return errors.map(error => {
    let friendlyMessage;

    // regex matches '.functions['xxx'].events[x].xxx'
    const isEventParam = /^\.functions\['[\w-_]+'\]\.events\[[0-9]+\]\.[\w]+$/.test(error.dataPath);
    if (error.params && error.params.additionalProperty && isEventParam) {
      const eventName = error.dataPath.split('.')[3];
      friendlyMessage = `Unsupported parameter '${error.params.additionalProperty}' for '${eventName}' event`;
    }

    // regex matches '.functions['xxx'].events[x]'
    const isFunctionEvent = /^\.functions\['[\w-_]+'\]\.events\[[0-9]+\]$/.test(error.dataPath);
    if (error.params && error.params.additionalProperty && isFunctionEvent) {
      friendlyMessage = `Unsupported function event '${error.params.additionalProperty}' at ${error.dataPath}`;
    }

    const isEventAnyOfErrorObject =
      error.keyword === 'anyOf' &&
      error.schemaPath === ANY_OF_EVENT_SCHEMA_PATH &&
      error.params.suberrors &&
      error.params.suberrors.length &&
      error.params.suberrors[0].params &&
      error.params.suberrors[0].params.additionalProperty;

    if (isEventAnyOfErrorObject) {
      friendlyMessage = `Unsupported function event '${error.params.suberrors[0].params.additionalProperty}' at ${error.dataPath}`;
    }

    const configUnderValidation = _.get(userConfig, error.dataPath.slice(1));

    if (isEventAnyOfErrorObject && Object.keys(configUnderValidation).length > 1) {
      const contextStr = `${Object.keys(configUnderValidation).length} (${Object.keys(
        configUnderValidation
      ).join(', ')})`;
      friendlyMessage = `Event should contain only one root property, but got ${contextStr} at ${error.dataPath}`;
    }

    if (error.dataPath === '.package' && error.params && error.params.additionalProperty) {
      friendlyMessage = [
        `Unsupported package property '${error.params.additionalProperty}' at ${error.dataPath}.`,
        'Avaiable properties are individually, path, artifact, exclude, include, excludeDevDependencies.',
      ].join(' ');
    }

    if (error.dataPath === '.functions' && error.params && error.params.additionalProperty) {
      friendlyMessage = `Function name '${error.params.additionalProperty}' must be alphanumeric at ${error.dataPath}.`;
    }

    // This is the case when error is related to root level of config
    if (error.dataPath === '' && error.params && error.params.additionalProperty) {
      friendlyMessage = `Unsupported root property '${error.params.additionalProperty}'`;
    }

    if (friendlyMessage) {
      error.friendlyMessage = friendlyMessage;
    }

    return error;
  });
};

module.exports = {
  buildErrorMessages,
  addUserFriendlyMessage,
};
