'use strict';
const _ = require('lodash');

const ANY_OF_EVENT_SCHEMA_PATH =
  '#/properties/functions/patternProperties/%5E%5Ba-zA-Z0-9-_%5D%2B%24/properties/events/items/anyOf';

// matches '#/properties/functions/patternProperties/%5E%5Ba-zA-Z0-9-_%5D%2B%24/properties/events/items/anyOf/123/additionalProperties'
const ANY_OF_SUB_ERROR_REGEX = /^#\/properties\/functions\/patternProperties\/%5E%5Ba-zA-Z0-9-_%5D%2B%24\/properties\/events\/items\/anyOf\/[\d]+\/additionalProperties$/;

// matches '#/properties/functions/patternProperties/%5E%5Ba-zA-Z0-9-_%5D%2B%24/properties/events/items/anyOf/17/properties/yourPluginEvent/properties/anotherProp/type'
const DEEPER_ANY_OF_SUB_ERROR_REGEX = /^#\/properties\/functions\/patternProperties\/%5E%5Ba-zA-Z0-9-_%5D%2B%24\/properties\/events\/items\/anyOf\/[\d]+\/properties\/.+$/;

/*
 * Structure AJV errors to prevent secondary errors related to 'anyOf' condition
 * are not shown. Those errors are placed in `suberrors` array of the most
 * relevant error.
 */
const structureAjvErrors = ajvErrors => {
  // If theres is no 'anyOf' error at schemaPath that equals to
  // then do nothing and return ajvErrors
  if (!ajvErrors.some(err => err.schemaPath === ANY_OF_EVENT_SCHEMA_PATH)) {
    return ajvErrors;
  }

  const anyOfErrorIndex = ajvErrors.findIndex(
    ajvError => ajvError.keyword === 'anyOf' && ajvError.schemaPath === ANY_OF_EVENT_SCHEMA_PATH
  );

  // Alternatively, if there is a deeper error, then it's better to make it parent
  // because it actually the reason why other errors are generated by AJV
  const deeperAnyOfErrorIndex = ajvErrors.findIndex(ajvError =>
    DEEPER_ANY_OF_SUB_ERROR_REGEX.test(ajvError.schemaPath)
  );

  const finalIndex = deeperAnyOfErrorIndex >= 0 ? deeperAnyOfErrorIndex : anyOfErrorIndex;

  const result = [ajvErrors[finalIndex]];
  result[0].params.suberrors = [];
  ajvErrors.forEach((ajvError, index) => {
    const isAnyOfSubError = ANY_OF_SUB_ERROR_REGEX.test(ajvError.schemaPath);

    if (deeperAnyOfErrorIndex >= 0) {
      if (isAnyOfSubError || index === anyOfErrorIndex) {
        result[0].params.suberrors.push(ajvError);
      } else if (index !== deeperAnyOfErrorIndex) {
        result.push(ajvError);
      }
    }

    if (deeperAnyOfErrorIndex < 0) {
      if (isAnyOfSubError) {
        result[0].params.suberrors.push(ajvError);
      } else if (index !== anyOfErrorIndex) {
        result.push(ajvError);
      }
    }
  });

  return result;
};

/*
 * For error object structure, see https://github.com/ajv-validator/ajv/#error-objects
 */
const buildErrorMessages = (ajvErrors, userConfig = {}) => {
  let errors = ajvErrors;

  errors = structureAjvErrors(errors);

  errors = addUserFriendlyMessage(errors, userConfig);

  errors = errors.sort((a, b) => b.dataPath.length - a.dataPath.length);
  if (!errors.length) throw new Error('Validation errors array cannot be emptry');

  return errors.map(error => {
    if (error.friendlyMessage) {
      return error.friendlyMessage;
    }
    return buildDefaultErrorMessage(error);
  });
};

const buildDefaultErrorMessage = ajvError => {
  switch (ajvError.keyword) {
    case 'additionalProperties': {
      let additionalProperty;
      if (ajvError.params && ajvError.params.additionalProperty) {
        additionalProperty = ajvError.params.additionalProperty;
      }
      const formattedDataPath = getFormattedDataPath(ajvError.dataPath);
      return `Unrecognized property '${additionalProperty}' on '${formattedDataPath}'`;
    }
    default:
      return `${getFormattedDataPath(ajvError.dataPath)} ${ajvError.message}`;
  }
};

const addUserFriendlyMessage = (errors, userConfig) => {
  return errors.map(error => {
    let friendlyMessage;

    // regex matches '.functions['xxx'].events[x].xxx'
    const isEventParam = /^\.functions\['[\w-_]+'\]\.events\[[0-9]+\]\.[\w]+$/.test(error.dataPath);
    if (error.params && error.params.additionalProperty && isEventParam) {
      const eventName = error.dataPath.split('.')[3];
      friendlyMessage = `Unsupported parameter '${error.params.additionalProperty}' for '${eventName}' event`;
    }

    // regex matches '.functions['xxx'].events[x]'
    const isFunctionEvent = /^\.functions\['[\w-_]+'\]\.events\[[0-9]+\]$/.test(error.dataPath);
    if (error.params && error.params.additionalProperty && isFunctionEvent) {
      friendlyMessage = `Unsupported function event '${
        error.params.additionalProperty
      }' at ${getFormattedDataPath(error.dataPath)}`;
    }

    const isEventAnyOfErrorObject =
      error.keyword === 'anyOf' &&
      error.schemaPath === ANY_OF_EVENT_SCHEMA_PATH &&
      error.params.suberrors &&
      error.params.suberrors.length &&
      error.params.suberrors[0].params &&
      error.params.suberrors[0].params.additionalProperty;

    if (isEventAnyOfErrorObject) {
      friendlyMessage = `Unsupported function event '${
        error.params.suberrors[0].params.additionalProperty
      }' at ${getFormattedDataPath(error.dataPath)}`;
    }

    const configUnderValidation = _.get(userConfig, error.dataPath.slice(1));

    if (isEventAnyOfErrorObject && Object.keys(configUnderValidation).length > 1) {
      const contextStr = `${Object.keys(configUnderValidation).length} (${Object.keys(
        configUnderValidation
      ).join(', ')})`;
      friendlyMessage = [
        'Event should contain only one root property,',
        `but got ${contextStr} at ${getFormattedDataPath(error.dataPath)}`,
      ].join(' ');
    }

    if (error.dataPath === '.functions' && error.params && error.params.additionalProperty) {
      friendlyMessage = `Function name '${
        error.params.additionalProperty
      }' must be alphanumeric at ${getFormattedDataPath(error.dataPath)}.`;
    }

    if (friendlyMessage) {
      error.friendlyMessage = friendlyMessage;
    }

    return error;
  });
};

function getFormattedDataPath(dataPath) {
  const result = dataPath === '' ? 'root' : dataPath.slice(1);

  // This regex helps replace functions['someFunc'].foo with functions.someFunc.foo
  const bracketsRegex = /\['([a-zA-Z_0-9]+)'\]/g;

  return result.replace(bracketsRegex, '.$1');
}

module.exports = {
  buildErrorMessages,
  addUserFriendlyMessage,
};
